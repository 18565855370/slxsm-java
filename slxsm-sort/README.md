#[Java排序算法](http://ju.outofmemory.cn/entry/372908)

###1：冒泡排序算法：
> 第一步：将数组两两比较，如果前一个大于后一个则交换位置，直至比较到最后一个，这样的到的结果最后一个数字为数组最大值。

> 第二步：重复上面的操作，但是最后一位不需要再进行比较（应为他已经是数组中最大一位了）。

> 第三步：重复玩第一步和第二步，都完成后数组则为从小到大有序排列（当然从大到小也是这样排序）。

> Note：这里只能是比较证书或者浮点数，其他类型数据不能这样比较。
> 冒泡算是是稳定的排序算法，最坏的情况就是每次都需要交换，共需要遍历n的2次/2次，时间复杂度为O(n的2次)。

> 由于冒泡排序只有缓存temp变量需要内存，所以空间复杂度为O(1) 。

> 工程示例见本工程bubble_sort目录的BubbleSort类。

平均时间复杂度： O(n 2 )，最好情况：O(n)，最坏情况：O(n 2 )，空间复杂度：O(1)

###2：快速排序
####1：填坑算法（挖坑递归法）
`快速排序并不稳定，快速排序每次交换的元素有可能不是相邻的，因此他有可能打破原来值为相同的元素之间的顺序。`
> 第一步：选取一个基准值。

> 第二步：从右往左每一个数字与基准值比较，找到打一个小于基准值的值，将选中的这个值放置在基准值位置（挖坑的位置），
基准值的坑再次挖到选中的这个数字位置。

> 第三部：从左往右每一个数字和基准值比较（这里注意被选为基准值的值不再拿出来和基准值比较，只作为基准值比较），找到大于基准值的，
将选中的这个只存放到坑的位置，基准值的坑再次挖到选中的这个数字位置。

> 第三步：第二步和第三步一直比较，直至左右两边挖的坑挖到了同一个位置。

> 第四步：重复第一步到第三步，直至排序完成。

####1：左右指针法
>第一步：和快速排序之挖坑排序第一第二不一样，知识将交换给到了swap，并无其他不一样

###3：直接插入算法
`直接插入算法共有两种实现方式，第一是位移法，第二是交换法，插入排序是不稳定的排序，时间复杂度为O(n 2 )，故不选择`。
####1：位移法
`位移法是将每一个元素和前面已经排序完成的列表比较，如果小于已排序的队列则插入，默认第一个元素是已排序的列表。`
> 第一步：第一个元素默认已被排序。

> 第二步：取出下一个元素，在已排序队列中从后向前扫描。

> 第三步：如果已排序的某个元素大于新元素，则将这个元素移到下个位置

> 第四步：将第三步重复，直至已排序的元素小于该新元素

> 第五步：将该元素插入到该位置

> 第六步：重复2~5步
####2：交换法
`交换法类似与冒泡排序，但是交换法时从后往前进行比较插入的，其实也类似与位移法`
###3：希尔排序
`希尔排序是比较稳定的插入排序算法，也被称为递减增量排序算法（虽然看不懂😄）`

> 第一步：将数组先分组，除以2，比如数组长度为10,分组为10/2 为5组，步长为5。也就是第一个和第六个比较，如果第一个小于第六个则交换，其他类似

> 第二步：第一步排序完成后（步长为5），现在再将步长为5的进行分组，5/2为2组（取整）,步长为2，也就是第一个和第三个比较，如果第一个比第三个大则交换，其他类似

> 第三步：第二步排序完成后（步长为2），现在再将步长为2的进行分组，2/2为1组，步长为1，就是两两比较，第一个比第二个大的化就交换

>如上类推，完成排序。