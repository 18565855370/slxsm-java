#[Java排序算法](http://ju.outofmemory.cn/entry/372908)

###1：冒泡排序算法：
> 第一步：将数组两两比较，如果前一个大于后一个则交换位置，直至比较到最后一个，这样的到的结果最后一个数字为数组最大值。

> 第二步：重复上面的操作，但是最后一位不需要再进行比较（应为他已经是数组中最大一位了）。

> 第三步：重复玩第一步和第二步，都完成后数组则为从小到大有序排列（当然从大到小也是这样排序）。

> Note：这里只能是比较证书或者浮点数，其他类型数据不能这样比较。
> 冒泡算是是稳定的排序算法，最坏的情况就是每次都需要交换，共需要遍历n的2次/2次，时间复杂度为O(n的2次)。

> 由于冒泡排序只有缓存temp变量需要内存，所以空间复杂度为O(1) 。

> 工程示例见本工程bubble_sort目录的BubbleSort类。

平均时间复杂度： O(n 2 )，最好情况：O(n)，最坏情况：O(n 2 )，空间复杂度：O(1)

###2：快速排序
####1：填坑算法（挖坑递归法）
`快速排序并不稳定，快速排序每次交换的元素有可能不是相邻的，因此他有可能打破原来值为相同的元素之间的顺序。`
> 第一步：选取一个基准值。

> 第二步：从右往左每一个数字与基准值比较，找到打一个小于基准值的值，将选中的这个值放置在基准值位置（挖坑的位置），
基准值的坑再次挖到选中的这个数字位置。

> 第三部：从左往右每一个数字和基准值比较（这里注意被选为基准值的值不再拿出来和基准值比较，只作为基准值比较），找到大于基准值的，
将选中的这个只存放到坑的位置，基准值的坑再次挖到选中的这个数字位置。

> 第三步：第二步和第三步一直比较，直至左右两边挖的坑挖到了同一个位置。

> 第四步：重复第一步到第三步，直至排序完成。

####1：左右指针法
>第一步：和快速排序之挖坑排序第一第二不一样，知识将交换给到了swap，并无其他不一样